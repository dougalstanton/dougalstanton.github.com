<!DOCTYPE html>
<html>

<head>
<title>Looking Out To Sea - Testing embedded C++ with Haskell QuickCheck</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="../style/reset.css" />
<link rel="stylesheet" type="text/css" href="../style/default.css" />
<link rel="stylesheet" type="text/css" href="../style/syntax.css" />
<link rel="alternate" type="application/rss+xml" href="../rss.xml" title="Dougal's blog" />
<link rel="alternate" type="application/atom+xml" href="../atom.xml" title="Dougal's blog" />
</head>

<body>
<div id="blog">

<header>
<h1>Looking Out To Sea</h1>
</header>

<nav>
<menu id="page_menu">
    <a href="../index.html">home</a> —
    <a href="../about.html">about</a> —
    <a href="../projects.html">projects</a> —
    <a href="../archive.html">archive</a>
</menu>
</nav>

<article>
<h2>Testing embedded C++ with Haskell QuickCheck</h2>
<section>
<p>If you work with C or C++ and are hankering after the testing power of <a href="http://hackage.haskell.org/package/QuickCheck" title="A library for random testing of program properties">QuickCheck for property tests</a>, this is your lucky day.</p>
<p>If you’ve got C++ code you have to bear a couple of things in mind. If it’s vanilla C then you’re okay.</p>
<ul>
<li>The code under test needs to be C-compatible, so using <code>extern C</code> otherwise the name mangler will prevent your linker from finding the correct symbols.</li>
<li>You have to manage the compilation steps manually or using an ordinary Makefile. The CABAL system doesn’t recognise <code>.cpp</code> files so won’t process them properly on its own.</li>
</ul>
<p>These are not grave restrictions by any means. This is how it’s done. First, we will see the files we have to start with. These are the ones which we have to write and cannot be autogenerated:</p>
<ul>
<li>foo.cpp</li>
<li>foo.h</li>
<li>Foo.hsc</li>
<li>Main.hs</li>
</ul>
<p>The first two comprise your “system under test”. The next two are the Haskell/C bridge file which handles marshalling and the Haskell test executable. As your system gets more complex you might obviously add to these.</p>
<p>I will work through this list of files in order, showing what they contain and how they can be used to generate further dependencies until the test system is complete.</p>
<h3 id="some-code-to-test">Some code to test</h3>
<p>First we have the C++ code we’re testing. I’m going to use the example of data transfer over a network. We’ve got some data structure which we need to transmit or receive. A simple way of testing whether we are internally consistent is making sure we can always decode the same data we encoded. This is the “round trip” test.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mtext mathvariant="monospace">id</mtext><mo>=</mo><mtext mathvariant="monospace">deserialise</mtext><mo>⋅</mo><mtext mathvariant="monospace">serialise</mtext></mrow></math></p>
<p>So <code>foo.cpp</code> contains a simple struct and a pair of functions that should operate as a “round trip”, serialising and then deserialising the input.</p>
<pre class="sourceCode cpp" include="includes/ffi-intro/foo.cpp"><code class="sourceCode cpp"><span class="ot">#include &quot;foo.h&quot;</span>

size_t serialise (<span class="dt">const</span> <span class="kw">struct</span> foo * in, <span class="dt">uint8_t</span> * out)
{
    out[<span class="dv">0</span>] = in-&gt;bar &amp; <span class="bn">0x000000ff</span>;
    out[<span class="dv">1</span>] = (in-&gt;bar &amp; <span class="bn">0x0000ff00</span>) &gt;&gt; <span class="dv">8</span>;
    out[<span class="dv">2</span>] = (in-&gt;bar &amp; <span class="bn">0x00ff0000</span>) &gt;&gt; <span class="dv">16</span>;
    out[<span class="dv">3</span>] = (in-&gt;bar &amp; <span class="bn">0xff000000</span>) &gt;&gt; <span class="dv">24</span>;
    out[<span class="dv">4</span>] = in-&gt;baz;
    out[<span class="dv">5</span>] = in-&gt;quux[<span class="dv">0</span>];
    out[<span class="dv">6</span>] = in-&gt;quux[<span class="dv">1</span>];
    out[<span class="dv">7</span>] = in-&gt;quux[<span class="dv">2</span>];
    out[<span class="dv">8</span>] = in-&gt;quux[<span class="dv">3</span>];
    <span class="kw">return</span> <span class="dv">9</span>; <span class="co">// bytes written</span>
}

size_t deserialise (<span class="dt">const</span> <span class="dt">uint8_t</span> * in, <span class="kw">struct</span> foo * out)
{
    out-&gt;bar = in[<span class="dv">0</span>] | in[<span class="dv">1</span>] &lt;&lt; <span class="dv">8</span> | in[<span class="dv">2</span>] &lt;&lt; <span class="dv">16</span> | in[<span class="dv">3</span>] &lt;&lt; <span class="dv">24</span>;
    out-&gt;baz = in[<span class="dv">4</span>];
    out-&gt;quux[<span class="dv">0</span>] = in[<span class="dv">5</span>];
    out-&gt;quux[<span class="dv">1</span>] = in[<span class="dv">6</span>];
    out-&gt;quux[<span class="dv">2</span>] = in[<span class="dv">6</span>];
    out-&gt;quux[<span class="dv">3</span>] = in[<span class="dv">8</span>];
    <span class="kw">return</span> <span class="dv">9</span>; <span class="co">// bytes recovered</span>
}</code></pre>
<p>I’ve hard-coded lots of stuff there, all the indices and the bytes read and written. I’ve also put an obvious bug into the indices to show the checker working. The header file is also important, because it defines what the interface is to the Haskell side (or any other code).</p>
<pre class="sourceCode cpp" include="includes/ffi-intro/foo.h"><code class="sourceCode cpp"><span class="ot">#include &lt;stdint.h&gt;</span>
<span class="ot">#include &lt;string.h&gt;</span>

<span class="ot">#ifdef __cplusplus</span>
<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> {
<span class="ot">#endif</span>

<span class="kw">typedef</span> <span class="kw">struct</span> foo
{
    <span class="dt">uint32_t</span> bar;
    <span class="dt">int8_t</span>   baz;
    <span class="dt">int8_t</span>   quux[<span class="dv">4</span>];
} foo_t;

size_t serialise   (<span class="dt">const</span> <span class="kw">struct</span> foo *, <span class="dt">uint8_t</span> *);
size_t deserialise (<span class="dt">const</span> <span class="dt">uint8_t</span> *, <span class="kw">struct</span> foo *);

<span class="ot">#ifdef __cplusplus</span>
}
<span class="ot">#endif</span></code></pre>
<p>In particular the header file should define the structure if we want to tell Haskell how it works.</p>
<p>As I said before, you need to ensure the <code>extern &quot;C&quot;</code> stuff is there otherwise you’ll fail at the linking stage. This means that polymorphic C++ code won’t work directly — you’ll have to write a C wrapper and attach to that.</p>
<p>To run Haskell tests on C++ code we need the C++ object file. I’m using the filename <code>foo.cpp.o</code> instead of <code>foo.o</code> here to highlight an important point. If you’re compiling all this in the same directory as the Haskell code, and you’ve got a <code>foo.cpp</code> and a <code>Foo.hs</code> then GHC will likely clobber the object file you’ve already written — it doesn’t pay attention to difference in case. So for simplicity’s sake, either rename the Haskell source file so it’s not the same or rename the C/C++ object file so it’s not the same.</p>
<pre><code>$ gcc -o foo.cpp.o -c foo.cpp</code></pre>
<p>If you forgot to tell the compiler that these are C-compatible functions with the <code>extern</code> keyword then the output will look like this:</p>
<pre><code>$ nm foo.cpp.o
0000000000000148 s EH_frame0
00000000000000b0 T __Z11deserialisePKhP3foo
0000000000000190 S __Z11deserialisePKhP3foo.eh
0000000000000000 T __Z9serialisePK3fooPh
0000000000000160 S __Z9serialisePK3fooPh.eh</code></pre>
<p>whereas we want them to look more like this:</p>
<pre><code>$ nm foo.cpp.o
0000000000000148 s EH_frame0
00000000000000b0 T _deserialise
0000000000000190 S _deserialise.eh
0000000000000000 T _serialise
0000000000000160 S _serialise.eh</code></pre>
<h3 id="bridging-the-gap">Bridging the gap</h3>
<p>Next we create a bridge between the two different languages. This is not difficult but can be a bit fiddly. I’m using Hsc2Hs here which is the simplest to understand but requires a bit of boilerplate. Essentially it’s a Haskell file with C-style interjections. The <code>hsc2hs</code> will process the C-like stuff and replace it with extra Haskell.</p>
<pre class="sourceCode haskell" include="includes/ffi-intro/Foo.hsc"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE ForeignFunctionInterface #-}</span>
<span class="kw">module</span> <span class="dt">Foo</span> <span class="kw">where</span>

<span class="fu">#</span>include <span class="st">&quot;foo.h&quot;</span>

<span class="kw">import</span> Foreign <span class="kw">hiding</span> (unsafePerformIO)
<span class="kw">import</span> Foreign.Marshal.Array
<span class="kw">import</span> Foreign.Storable
<span class="kw">import</span> System.IO.Unsafe (unsafePerformIO)

<span class="kw">data</span> <span class="dt">Foo</span> <span class="fu">=</span> <span class="dt">Foo</span>
    {<span class="ot"> fooBar  ::</span> <span class="fu">#</span>{<span class="kw">type</span> uint32_t}
    ,<span class="ot"> fooBaz  ::</span> <span class="fu">#</span>{<span class="kw">type</span> int8_t}
    ,<span class="ot"> fooQuux ::</span> [<span class="fu">#</span>{<span class="kw">type</span> int8_t}]
    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)

<span class="kw">instance</span> <span class="dt">Storable</span> <span class="dt">Foo</span> <span class="kw">where</span>
    sizeOf _    <span class="fu">=</span> <span class="fu">#</span>{size foo_t}
    alignment _ <span class="fu">=</span> alignment (undefined<span class="ot"> ::</span> <span class="dt">Word32</span>)

    peek ptr <span class="fu">=</span> <span class="kw">do</span>
        r1 <span class="ot">&lt;-</span> <span class="fu">#</span>{peek foo_t, bar} ptr
        r2 <span class="ot">&lt;-</span> <span class="fu">#</span>{peek foo_t, baz} ptr
        r3 <span class="ot">&lt;-</span> peekArray <span class="dv">4</span> <span class="fu">$</span> <span class="fu">#</span>{ptr foo_t, quux} ptr
        return (<span class="dt">Foo</span> r1 r2 r3)

    poke ptr (<span class="dt">Foo</span> r1 r2 r3) <span class="fu">=</span> <span class="kw">do</span>
        <span class="fu">#</span>{poke foo_t, bar} ptr r1
        <span class="fu">#</span>{poke foo_t, baz} ptr r2
        pokeArray (<span class="fu">#</span>{ptr foo_t, quux} ptr) r3

<span class="kw">type</span> <span class="dt">Buffer</span> <span class="fu">=</span> [<span class="dt">Word8</span>]

foreign <span class="kw">import</span> ccall &quot;foo.h serialise&quot;
<span class="ot">    c_serialise ::</span> <span class="dt">Ptr</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>
foreign <span class="kw">import</span> ccall &quot;foo.h deserialise&quot;
<span class="ot">    c_deserialise ::</span> <span class="dt">Ptr</span> <span class="dt">Word8</span> <span class="ot">-&gt;</span> <span class="dt">Ptr</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Int</span>

<span class="ot">serialise ::</span> <span class="dt">Foo</span> <span class="ot">-&gt;</span> <span class="dt">Buffer</span>
serialise foo <span class="fu">=</span> unsafePerformIO <span class="fu">$</span> with foo <span class="fu">$</span>
    \foo_ptr <span class="ot">-&gt;</span> allocaArray (sizeOf foo) <span class="fu">$</span>
    \buf_ptr <span class="ot">-&gt;</span> <span class="kw">do</span>
        sz <span class="ot">&lt;-</span> c_serialise foo_ptr buf_ptr
        peekArray sz buf_ptr

<span class="ot">deserialise ::</span> <span class="dt">Buffer</span> <span class="ot">-&gt;</span> <span class="dt">Foo</span>
deserialise buf <span class="fu">=</span> unsafePerformIO <span class="fu">$</span> withArray buf <span class="fu">$</span>
    \buf_ptr <span class="ot">-&gt;</span> allocaBytes (sizeOf (undefined<span class="ot"> ::</span> <span class="dt">Foo</span>)) <span class="fu">$</span>
    \foo_ptr <span class="ot">-&gt;</span> <span class="kw">do</span>
        _ <span class="ot">&lt;-</span> c_deserialise buf_ptr foo_ptr
        peek foo_ptr</code></pre>
<p>There’s a bit of personal choice as to how you interpret some of the datatypes in Haskell. You can consider a boolean value as <code>Bool</code> or as <code>Word8</code>; one more closely models the data but the other more closely models the semantics. In this case I use the <code>#{type}</code> directive which models the C type completely — the preprocessor can’t know that it’s a boolean being represented. I think this is better if you’re testing C/C++ code because it allows you to pass any valid number rather than only emitting <code>0</code> or <code>1</code>. If you want to model the semantics there are some utility functions like <code>toBool</code> and <code>fromBool</code> which will convert the data properly.</p>
<p>See also <a href="http://therning.org/magnus/archives/315" title="Using hsc2hs to marshall C structs">Magnus Therning’s informative blog post about Hsc2Hs</a>. We compile like so:</p>
<pre><code>$ hsc2hs Foo.hsc</code></pre>
<p>Now we have a C object file created by GCC and a Haskell source file created by Hsc2Hs.</p>
<ul>
<li>foo.cpp.o</li>
<li>Foo.hs</li>
</ul>
<p>If the marshalling in <code>Foo.hsc</code> is defined correctly you should be able to load the generated Haskell file into GHCi alongside the C++ object file to exercise it.</p>
<pre><code>$ ghci Foo.hs foo.cpp.o</code></pre>
<h3 id="some-code-to-test-with">Some code to test with</h3>
<p>All that’s needed now is your tests. If the code you are testing does not maintain state then all the better: you can wrap the FFI calls in <code>unsafePerformIO</code> to convince the type system that they’re pure computations. The Haskell compiler doesn’t know the external code is pure so this is your promise to the type system that it <em>is</em> pure. If you are in fact lying (or in error) then you may find odd behaviour or crashes.</p>
<pre class="sourceCode haskell" include="includes/ffi-intro/Main.hs"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>

<span class="kw">import</span> Foo

<span class="kw">import</span> Test.QuickCheck

<span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Foo</span> <span class="kw">where</span>
    arbitrary <span class="fu">=</span> <span class="kw">do</span>
        foobar  <span class="ot">&lt;-</span> arbitrary
        foobaz  <span class="ot">&lt;-</span> arbitrary
        fooquux <span class="ot">&lt;-</span> vector <span class="dv">4</span>
        return (<span class="dt">Foo</span> foobar foobaz fooquux)

prop_roundtrip <span class="fu">=</span> property <span class="fu">$</span>
    \foo <span class="ot">-&gt;</span> foo <span class="fu">==</span> deserialise (serialise foo)

main <span class="fu">=</span> quickCheck prop_roundtrip</code></pre>
<p>Auto-generating tests is much easier now that you’ve dragged the code over from the dark side. Remember to include your precompiled object file on the command line when you’re building your Haskell code.</p>
<pre><code>$ ghc --make Main.hs foo.cpp.o -o tests</code></pre>
<p>Even better of course is to write a Makefile which will do everything like that for you:</p>
<pre class="sourceCode makefile" include="includes/ffi-intro/Makefile"><code class="sourceCode makefile"><span class="dv">tests:</span><span class="dt"> Main.hs Foo.hs foo.cpp.o</span>
	ghc --make Main foo.cpp.o -o tests

<span class="dv">foo.cpp.o:</span><span class="dt"> foo.cpp foo.h</span>
	gcc -c foo.cpp -o foo.cpp.o

<span class="dv">Foo.hs:</span><span class="dt"> Foo.hsc foo.h</span>
	hsc2hs -I. Foo.hsc

<span class="dv">clean:</span>
	rm -rf *.hi *.o tests Foo.hs</code></pre>
<p>Let’s see how things fare when we attempt to check our roundtrip property.</p>
<pre><code>$ make
hsc2hs -I. Foo.hsc
gcc -c foo.cpp -o foo.cpp.o
ghc --make Main foo.cpp.o -o tests
[1 of 2] Compiling Foo              ( Foo.hs, Foo.o )
[2 of 2] Compiling Main             ( Main.hs, Main.o )
Linking tests ...

$ ./tests
Falsifiable (after 1 test): 
Foo {fooBar = 1, fooBaz = -1, fooQuux = [-1,-1,0,0]}</code></pre>
<p>Oh dear! Not a great outcome there… But now you can load up GHCi and manually run that test to see what result you get when serialising and deserialising, examining the intermediate data and ultimately tracking down the bug.</p>
</section>
</article>

</div>
</body>

</html>
